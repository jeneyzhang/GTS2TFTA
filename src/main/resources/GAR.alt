block GARSystem
    ComponentState ACSLA.s(init = WORKING);
    ComponentState ACSLB.s(init = WORKING);
    ComponentState ARA1A.s(init = WORKING);
    ComponentState ARS1B.s(init = WORKING);
    SpareComponentState GPML1.s(init = WORKING);
    SpareComponentState GPML2.s(init = STANDBY);
    SpareComponentState RDIU1.s(init = WORKING);
    SpareComponentState RDIU2.s(init = STANDBY);
    ComponentState s1.s(init = FAILED);
    ComponentState s2.s(init = FAILED);
    Boolean A1.inFlow(reset = FALSE);
    Boolean A1.outFlow(reset = FALSE);
    Boolean A2.inFlow(reset = FALSE);
    Boolean A2.outFlow(reset = FALSE);
    Boolean ACSLA.inFlow(reset = FALSE);
    Boolean ACSLA.outFlow(reset = FALSE);
    Boolean ACSLB.inFlow(reset = FALSE);
    Boolean ACSLB.outFlow(reset = FALSE);
    Boolean ARS1A.inFlow(reset = FALSE);
    Boolean ARS1A.outFlow(reset = FALSE);
    Boolean ARS1B.inFlow(reset = FALSE);
    Boolean ARS1B.outFlow(reset = FALSE);
    Boolean B1.inFlow(reset = FALSE);
    Boolean B1.outFlow(reset = FALSE);
    Boolean B2.inFlow(reset = FALSE);
    Boolean B2.outFlow(reset = FALSE);
    Boolean GPML1.inFlow(reset = FALSE);
    Boolean GPML1.outFlow(reset = FALSE);
    Boolean GPML2.inFlow(reset = FALSE);
    Boolean GPML2.outFlow(reset = FALSE);
    Boolean RDIU1.inFlow(reset = TRUE);
    Boolean RDIU1.outFlow(reset = FALSE);
    Boolean RDIU2.inFlow(reset = FALSE);
    Boolean RDIU2.outFlow(reset = FALSE);
    Boolean s.outFlow(reset = TRUE);
    event ACSLA.failure;
    event ACSLB.failure;
    event ARS1A.failure;
    event ARS1B.failure;
    event GPML1.failure;
    event GPML1.start;
    event GPML2.failure;
    event GPML2.start;
    event RDIU1.failure;
    event RDIU1.start;
    event RDIU2.failure;
    event RDIU2.start;
    event s1.failure;
    event s2.failure;
    event ccf;
    transition ACSLA.failure : ACSLA.s == WORKING -> ACSLA.s := FAILED;
    transition ACSLB.failure : ACSLB.s == WORKING -> ACSLB.s := FAILED;
    transition ARS1A.failure : ARS1A.s == WORKING -> ARS1A.s := FAILED;
    transition ARS1B.failure : ARS1B.s == WORKING -> ARS1B.s := FAILED;
    transition GPML1.failure : GPML1.s == WORKING -> GPML1.s := FAILED;
    transition GPML2.start : GPML2.s == STANDBY -> GPML2.s := WORKING;
    transition GPML2.failure : GPML2.s == WORKING -> GPML2.s := FAILED;
    transition RDIU1.start : RDIU1.s == STANDBY -> RDIU1.s := WORKING;
    transition RDIU1.failure : RDIU1.s == WORKING -> RDIU1.s := FAILED;
    transition RDIU2.start : RDIU2.s == STANDBY -> RDIU2.s := WORKING;
    transition RDIU2.failure : RDIU2.s == WORKING -> RDIU2.s := FAILED;
    transition s1.failure : s1.s == WORKING -> s1.s := FAILED;
    transition s2.failure : s2.s == WORKING -> s2.s := FAILED;
    transition ccf : GPML1.s == WORKING or s2.s == FAILED -> {if GPML1.s == WORKING then GPML1.s := FAILED;if GPML1.s == FAILED and s2.s == FAILED then s2.s := WORKING};
    assertion if ACSLA.s == WORKING and ACSLA.inFlow then ACSLA.outFlow := TRUE;
    assertion if ACSLB.s == WORKING and ACSLB.inFlow then ACSLB.outFlow := TRUE;
    assertion if ARS1A.s == WORKING and ARS1A.inFlow then ARS1A.outFlow := TRUE;
    assertion if ARS1B.s == WORKING and ARS1B.inFlow then ARS1B.outFlow := TRUE;
    assertion if GPML1.s == WORKING and GPML1.inFlow then GPML1.outFlow := TRUE;
    assertion if GPML2.s == WORKING and GPML2.inFlow then GPML2.outFlow := TRUE;
    assertion if RDIU1.s == WORKING and RDIU1.inFlow then RDIU1.outFlow := TRUE;
    assertion if RDIU2.s == WORKING and RDIU2.inFlow then RDIU2.outFlow := TRUE;
    assertion RDIU1.inFlow := s.outFlow;
    assertion RDIU2.inFlow := s1.outFlow and s.outFlow;
    assertion s1.inFlow := RDIU1.outFlow;
    assertion A1.inFlow := RDIU1.outFlow or RDIU2.outFlow;
    assertion B1.inFlow := RDIU1.outFlow or RDIU2.outFlow;
    assertion ARS1A.inFlow := A1.outFlow;
    assertion ARS1B.inFlow := B1.outFlow;
    assertion ACSLA.inFlow := ARS1A.outFlow;
    assertion ACSLB.inFlow := ARS1B.outFlow;
    assertion A2.inFlow := ACSLA.outFlow;
    assertion B2.inFlow := ACSLB.outFlow;
    assertion GPML1.inFlow := A2.outFlow or B2.outFlow;
    assertion s2.inFlow := GPML1.outFlow;
    assertion GPML2.inFlow := A2.outFlow or B2.outFlow and s2.outFlow;
end