block IMASystem
    Boolean A.inFlow(reset = FALSE);
    Boolean A.outFlow(reset = FALSE);
    ComponentState A.s(init = WORKING);
    Boolean B.inFlow(reset = FALSE);
    Boolean B.outFlow(reset = FALSE);
    ComponentState B.s(init = WORKING);
    Boolean A1.inFlow(reset = FALSE);
    Boolean A1.outFlow(reset = FALSE);
    ComponentState A1.s(init = WORKING);
    Boolean A2.inFlow(reset = FALSE);
    Boolean A2.outFlow(reset = FALSE);
    ComponentState A2.s(init = WORKING);
    Boolean B1.inFlow(reset = FALSE);
    Boolean B1.outFlow(reset = FALSE);
    ComponentState B1.s(init = WORKING);
    Boolean B2.inFlow(reset = FALSE);
    Boolean B2.outFlow(reset = FALSE);
    ComponentState B2.s(init = WORKING);
    Boolean ACSLA.inFlow(reset = FALSE);
    Boolean ACSLA.outFlow(reset = FALSE);
    ComponentState ACSLA.s(init = WORKING);
    Boolean ACSLB.inFlow(reset = FALSE);
    Boolean ACSLB.outFlow(reset = FALSE);
    ComponentState ACSLB.s(init = WORKING);
    Boolean ARS1A.inFlow(reset = FALSE);
    Boolean ARS1A.outFlow(reset = FALSE);
    ComponentState ACSLA.s(init = WORKING);
    Boolean ARS1B.inFlow(reset = FALSE);
    Boolean ARS1B.outFlow(reset = FALSE);
    ComponentState ARS1B.s(init = WORKING);
    Boolean GPML1.inFlow(reset = FALSE);
    ComponentState GPML1.s(init = WORKING);
    Boolean RDIU1.inFlow(reset = FALSE);
    Boolean RDIU1.outFlow(reset = FALSE);
    ComponentState RDIU1.s(init = WORKING);
    Boolean RDIU2.inFlow(reset = FALSE);
    Boolean RDIU2.outFlow(reset = FALSE);
    SpareComponentState RDIU2.s(init = STANDBY);
    Boolean s1.outFlow(reset = FALSE);
    ComponentState s1.s(init = WORKING);
    Boolean s2.inFlow(reset = FALSE);
    Boolean s2.outFlow(reset = FALSE);
    Boolean s2.isClosed(reset = TRUE);
    ComponentState s2.s(init = WORKING);
    event A.failure;
    event B.failure;
    event A1.failure;
    event A2.failure;
    event B1.failure;
    event B2.failure;
    event ACSLA.failure;
    event ACSLB.failure;
    event ARS1A.failure;
    event ARS1B.failure;
    event GPML1.failure;
    event RDIU1.failure;
    event RDIU1.start;
    event RDIU2.failure;
    event RDIU2.start;
    event s1.failure;
    event s2.failure;
    event s2.open;
    event s2.close;
    transition A.failure : A.s == WORKING -> A.s := FAILED;
    transition B.failure : B.s == WORKING -> B.s := FAILED;
    transition A1.failure : A1.s == WORKING -> A1.s := FAILED;
    transition A2.failure : A2.s == WORKING -> A2.s := FAILED;
    transition B1.failure : B1.s == WORKING -> B1.s := FAILED;
    transition B2.failure : B2.s == WORKING -> B2.s := FAILED;
    transition ACSLA.failure : ACSLA.s == WORKING -> ACSLA.s := FAILED;
    transition ACSLB.failure : ACSLB.s == WORKING -> ACSLB.s := FAILED;
    transition ARS1A.failure : ARS1A.s == WORKING -> ARS1A.s := FAILED;
    transition ARS1B.failure : ARS1B.s == WORKING -> ARS1B.s := FAILED;
    transition GPML1.failure : GPML1.s == WORKING -> GPML1.s := FAILED;
    transition RDIU1.failure : RDIU1.s == WORKING -> RDIU1.s := FAILED;
    transition s2.open : s2.isClosed and s2.s == WORKING -> s2.isClosed == FALSE;
    transition s2.close : not s2.isClosed and s2.s == WORKING -> s2.isClosed == TRUE;
    transition s2.failure : s2.s == WORKING -> s2.s == FAILED;
    transition RDIU2.start : s2.s == WORKING and RDIU2.s == STANDBY -> RDIU2.s := WORKING;
    transition RDIU2.failure : RDIU2.s == WORKING -> RDIU2.s := FAILED;
    transition s1.failure : s1.s == WORKING -> s1.s := FAILED;
    transition s2.failure : s2.s == WORKING -> s2.s := FAILED;
    assertion if A1.s == WORKING and A1.inFlow then A1.outFlow := TRUE;
    assertion if A2.s == WORKING and A2.inFlow then A2.outFlow := TRUE;
    assertion if B1.s == WORKING and B1.inFlow then B1.outFlow := TRUE;
    assertion if B2.s == WORKING and B2.inFlow then B2.outFlow := TRUE;
    assertion if ACSLA.s == WORKING and ACSLA.inFlow then ACSLA.outFlow := TRUE;
    assertion if ACSLB.s == WORKING and ACSLB.inFlow then ACSLB.outFlow := TRUE;
    assertion if ARS1A.s == WORKING and ARS1A.inFlow then ARS1A.outFlow := TRUE;
    assertion if ARS1B.s == WORKING and ARS1B.inFlow then ARS1B.outFlow := TRUE;
    assertion if GPML1.s == WORKING and GPML1.inFlow then GPML1.outFlow := TRUE;
    assertion if RDIU1.s == WORKING and RDIU1.inFlow then RDIU1.outFlow := TRUE;
    assertion if RDIU2.s == WORKING and RDIU2.inFlow then RDIU2.outFlow := TRUE;
    assertion if s1.s == WORKING and s1.inFlow then s1.outFlow := TRUE;
    assertion if not s2.isCloesd then s2.outFlow := s2.inFlow;
    assertion RDIU1.inFlow := s1.outFlow;
    assertion s2.inFlow := RDIU1.outFlow;
    assertion RDIU2.inFlow := s1.outFlow and s2.outFlow;
    assertion A1.inFlow := RDIU1.outFlow;
    assertion B1.inFlow := RDIU1.outFlow;
    assertion A2.inFlow := RDIU2.outFlow;
    assertion B2.inFlow := RDIU2.outFlow;
    assertion ARS1A.inFlow := A1.outFlow or A2.outFlow;
    assertion ARS1B.inFlow := B1.outFlow or B2.outFlow;
    assertion ACSLA.inFlow := ARS1A.outFlow;
    assertion ACSLB.inFlow := ARS1B.outFlow;
    assertion A.inFlow := ACSLA.outFlow;
    assertion B.inFlow := ACSLB.outFlow;
    assertion GPML1.inFlow := A.outFlow or B.outFlow;
end